<div class="game-board"
     style="--tile-size: @(TileSize)px; width: @(Game.TotalColumns * TileSize)px; height: @(Rows * TileSize)px"
     @onmouseleave="ClearHighlight">
    @foreach (var brick in GetAllBricks())
    {
        <BrickCell @key="brick.Id"
                   Brick="brick"
                   Color="brick.Color"
                   IsHighlighted="_highlightedBricks.Contains(brick)"
                   IsRemoving="_removingBrickIds.Contains(brick.Id)"
                   PositionStyle="@GetPositionStyle(brick)"
                   HighlightBorderCss="@GetBorderCss(brick)"
                   OnBrickHover="HandleBrickHover"
                   OnBrickClick="HandleBrickClick" />
    }
</div>

@code {
    [Parameter] public TetriBricksGame Game { get; set; } = default!;
    [Parameter] public int TileSize { get; set; } = 20;
    [Parameter] public int Rows { get; set; }
    [Parameter] public bool IsTouchDevice { get; set; }
    [Parameter] public EventCallback<Brick> OnBrickClick { get; set; }
    [Parameter] public EventCallback<int> OnPreviewPoints { get; set; }

    private HashSet<Brick> _highlightedBricks = new();
    private HashSet<int> _removingBrickIds = new();
    private Brick? _selectedBrick;
    private bool _isAnimating;

    private IEnumerable<Brick> GetAllBricks()
    {
        // Include removing bricks (from snapshot) plus current game bricks
        var currentBricks = Game.Bricks;
        if (_removingBrickIds.Count > 0)
        {
            // During removal phase, _removingSnapshot has the bricks being removed
            // and current game bricks are the ones that remain
            foreach (var brick in _removingSnapshot)
                yield return brick;
        }
        foreach (var brick in currentBricks)
        {
            if (!_removingBrickIds.Contains(brick.Id))
                yield return brick;
        }
    }

    private List<Brick> _removingSnapshot = new();

    private string GetPositionStyle(Brick brick)
    {
        return $"left:{brick.Column * TileSize}px;bottom:{brick.Row * TileSize}px";
    }

    private async Task HandleBrickHover(Brick brick)
    {
        if (IsTouchDevice || _isAnimating) return;

        _highlightedBricks.Clear();
        var adjacent = Game.GetAdjacentBricks(brick);
        if (adjacent.Count > 1)
        {
            foreach (var b in adjacent)
                _highlightedBricks.Add(b);
            await OnPreviewPoints.InvokeAsync((int)Math.Pow(adjacent.Count, 2));
        }
        else
        {
            await OnPreviewPoints.InvokeAsync(0);
        }
    }

    private void ClearHighlight()
    {
        if (IsTouchDevice || _isAnimating) return;

        _highlightedBricks.Clear();
        OnPreviewPoints.InvokeAsync(0);
    }

    private async Task HandleBrickClick(Brick brick)
    {
        if (_isAnimating) return;

        if (IsTouchDevice)
        {
            await HandleTouchTap(brick);
            return;
        }

        await AnimateAndRemove(brick);
    }

    private async Task AnimateAndRemove(Brick brick)
    {
        var adjacent = Game.GetAdjacentBricks(brick);
        if (adjacent.Count <= 1) return;

        _isAnimating = true;

        // Phase 1: Shrink & fade out removed bricks
        _removingSnapshot = adjacent.ToList();
        _removingBrickIds = new HashSet<int>(adjacent.Select(b => b.Id));
        _highlightedBricks.Clear();
        _selectedBrick = null;
        await OnPreviewPoints.InvokeAsync(0);
        StateHasChanged();

        await Task.Delay(300);

        // Phase 2: Clear removing state, trigger actual removal (game state update)
        _removingBrickIds.Clear();
        _removingSnapshot.Clear();
        await OnBrickClick.InvokeAsync(brick);
        StateHasChanged();

        // Wait for slide transition
        await Task.Delay(300);

        _isAnimating = false;
    }

    private string GetBorderCss(Brick brick)
    {
        if (!_highlightedBricks.Contains(brick))
            return "";

        var css = "";

        // row+1 is visually up, row-1 is visually down (bottom-based positioning)
        if (!_highlightedBricks.Any(b => b.Column == brick.Column && b.Row == brick.Row + 1))
            css += "hl-border-top ";
        if (!_highlightedBricks.Any(b => b.Column == brick.Column && b.Row == brick.Row - 1))
            css += "hl-border-bottom ";
        if (!_highlightedBricks.Any(b => b.Row == brick.Row && b.Column == brick.Column - 1))
            css += "hl-border-left ";
        if (!_highlightedBricks.Any(b => b.Row == brick.Row && b.Column == brick.Column + 1))
            css += "hl-border-right ";

        return css.TrimEnd();
    }

    private async Task HandleTouchTap(Brick brick)
    {
        if (_isAnimating) return;

        var adjacent = Game.GetAdjacentBricks(brick);

        if (adjacent.Count <= 1)
        {
            // Lone brick - clear selection
            _highlightedBricks.Clear();
            _selectedBrick = null;
            await OnPreviewPoints.InvokeAsync(0);
            return;
        }

        if (_selectedBrick is not null && _highlightedBricks.Contains(brick))
        {
            // Second tap on highlighted group - confirm removal with animation
            await AnimateAndRemove(brick);
            return;
        }

        // First tap or tap on different group - highlight
        _highlightedBricks.Clear();
        foreach (var b in adjacent)
            _highlightedBricks.Add(b);
        _selectedBrick = brick;
        await OnPreviewPoints.InvokeAsync((int)Math.Pow(adjacent.Count, 2));
    }
}
